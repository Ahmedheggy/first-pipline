image: docker:24.0.7  # Use a Docker image

variables:
  DOCKER_HOST: unix:///var/run/docker.sock  # Use socket mounting
  DOCKER_TLS_CERTDIR: ""  # Disable TLS to prevent authentication issues
  POSTGRES_DB: mydatabase
  POSTGRES_USER: user
  POSTGRES_PASSWORD: password
  REDIS_HOST: redis
  DATABASE_URL: postgresql://user:password@db:5432/mydatabase
  COMPOSE_HTTP_TIMEOUT: 300  # Avoid timeout issues

stages:
  - build
  - test

before_script:
  - apk add --no-cache docker-compose  # Install docker-compose
  - docker --version  # Verify Docker installation
  - docker-compose --version  # Verify docker-compose installation
  - echo "Ensuring Docker is ready..."
  - sleep 5  # Give Docker time to initialize
  - docker info  # Debug Docker status

build_job:
  stage: build
  services:
    - name: docker:dind  # ✅ Enable Docker-in-Docker
      command: ["--tls=false"]
  script:
    - apk add --no-cache curl
    - echo "Checking out the repository..."
    - ls -la  # ✅ Debug: List all files to verify `compose.yml` is present
    - |
      if test -f compose.yml; then
        echo "compose.yml exists!";
      else
        echo "ERROR: compose.yml is missing!";
        exit 1;
      fi
    - echo "Removing networks from compose.yml for build..."
    - sed '/networks:/,/my_network/d' compose.yml > compose.build.yml  # ✅ Remove networks from a copy
    - echo "Building the Docker images..."
    - docker-compose -f compose.build.yml build --no-cache
  tags:
    - docker

test_job:
  stage: test
  services:
    - name: docker:dind
      command: ["--privileged"]
     
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_DRIVER: overlay2
  script:
    - apk add --no-cache curl jq
    - echo "Checking if Docker-in-Docker is running..."
    - docker info || (echo "Docker-in-Docker failed to start"; exit 1)
    - echo "Checking Docker Networks..."
    - docker network ls
    - echo "Ensuring my_network exists..."
    - docker network create my_network || echo "Network already exists"
    - echo "Starting Docker Compose services..."
    - docker-compose up -d --remove-orphans
    - echo "Checking Running Containers..."
    - docker ps -a
    - echo "Manually connecting web, db, and redis to my_network..."
    - docker network connect my_network first_pipeline-web-1 || echo "Web already connected"
    - docker network connect my_network first_pipeline-db-1 || echo "DB already connected"
    - docker network connect my_network first_pipeline-redis-1 || echo "Redis already connected"
    - echo "Re-checking network..."
    - docker network inspect my_network
    - echo "Extracting Web Container IP..."
    - WEB_IP=$(docker network inspect my_network | jq -r '.[] | .Containers | to_entries[] | select(.value.Name=="first_pipeline-web-1") | .value.IPv4Address' | cut -d'/' -f1)
    - if [ -z "$WEB_IP" ]; then echo "ERROR:WEB_IP is empty!"; exit 1; fi
    - echo "Web Container IP:$WEB_IP"
    - echo "Waiting for Flask app to be ready..."
    - timeout 60 sh -c "until curl -v http://$WEB_IP:5000/; do sleep 5; done" || (echo "App failed to start" && exit 1)
    - echo "App is running!"
  tags:
    - docker
  after_script:
    - docker-compose down --remove-orphans || true

debug_networks:
  stage: test
  services:
    - name: docker:dind  # ✅ Enable Docker-in-Docker
      command: ["--tls=false"]
  script:
    - echo "Checking Docker Networks..."
    - docker network ls  # ✅ List available networks
    - echo "Inspecting my_network..."
    - docker network inspect my_network || echo "Network does not exist"
  tags:
    - docker
  when: manual  # ✅ Allows you to manually trigger the job in GitLab UI
  allow_failure: true  # ✅ Prevents pipeline from failing while debugging

